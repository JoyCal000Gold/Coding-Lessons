---
title: "Lesson One"
format: html
#This is YAML comment, will not be rendered
#Our shell (low-level control) is bash, and there things called shell scripts
---

# Introduction

This is a simple Quarto lesson with Python and R code chunks.<!-- This is a markdown comment, will not be rendered-->

In this lesson, we explore the difference between **rendering** a document with embedded code and **compiling** code in compiled languages like C++ and Rust.

- **Rendering** runs code chunks inside the document, capturing output (like Python, R).
- **Compiling** means transforming source code into an executable binary, which is then run separately.
- Some languages (Python, R) are interpreted and run seamlessly.
- Others (C++, Rust) require external compilation.

The other objective is learning types of mutablity and how that affected by langauge syntx and language philosophy. 

---

```{r setup, include=FALSE}

knitr::knit_engines$set(
  rust = function(options) {
    code <- paste(options$code, collapse = "\n")
    tmp_rs <- tempfile(fileext = ".rs")
    tmp_bin <- tempfile()
    writeLines(code, tmp_rs)

    compile_res <- system2("rustc", c(tmp_rs, "-o", tmp_bin), stdout = TRUE, stderr = TRUE)

    if (length(compile_res) > 0) {
      return(knitr::engine_output(options, code, compile_res))
    }

    output <- system(tmp_bin, intern = TRUE)

    knitr::engine_output(options, code, output)
  },
  
  cpp = function(options) {
    code <- paste(options$code, collapse = "\n")
    tmp_cpp <- tempfile(fileext = ".cpp")
    tmp_bin <- tempfile()
    writeLines(code, tmp_cpp)

    # Compile C++ code using g++
    compile_res <- system2("g++", c(tmp_cpp, "-o", tmp_bin), stdout = TRUE, stderr = TRUE)

    if (length(compile_res) > 0) {
      return(knitr::engine_output(options, code, compile_res))
    }

    output <- system(tmp_bin, intern = TRUE)

    knitr::engine_output(options, code, output)
  }
)
```

# Python chunk (automatically renders and compiles)
```{python}
# Python code example
import numpy as np

print("Hello from Python!")
print(f"Random number: {np.random.rand()}")

x = [1, 2, 3]
y = x
y[0] = 99
print("x:", x)
print("y:", y)
```

# R chunk (automatically renders and compiles)
```{r}
print("Hello from R!")
print(runif(1))

x <- c(1, 2, 3)
y <- x
y[1] <- 99  # Change first element of y (indexing starts at 1 in R)

print(x)
print(y)
```

<!-- Save your code to example.cpp Compile with: g++ -o example example.cpp Run with: ./example -->
# C++ chunk 
```{cpp}
#include <iostream>
#include <vector>

int main() {
    std::vector<int> x = {1, 2, 3};
    std::vector<int> y = x;
    y[0] = 99;

    std::cout << "x: ";
    for (int val : x) std::cout << val << " ";
    std::cout << std::endl;

    std::cout << "y: ";
    for (int val : y) std::cout << val << " ";
    std::cout << std::endl;

    return 0;
}
```

<!-- Save as example.rs Compile with: rustc example.rs Run with: ./example -->
# Rust chunks 

```{rust}
fn run_case(case: &str) {
    println!("=== Running Case: '{}' ===", case);

    match case {
        "immutable" => {
            println!("üîç Description:");
            println!("This case demonstrates an *immutable borrow* of a vector.");
            println!("You can read from the original (x) and the reference (y), but not mutate either.");
            println!("Since y is just borrowing x immutably, both can be used simultaneously.\n");

            let x = vec![1, 2, 3];
            let y = &x;

            println!("‚úÖ x: {:?}", x);
            println!("‚úÖ y (immutable borrow): {:?}", y);
        }

        _ => {
            eprintln!("‚ùå Unknown case '{}'", case);
        }
    }

    println!("==============================\n");
}

fn main() {
    run_case("immutable");
}
```

```{rust}
fn run_case(case: &str) {
    println!("=== Running Case: '{}' ===", case);

    match case {
        "mutable_clone" => {
            println!("üîç Description:");
            println!("This case shows what happens when you *clone* a vector and mutate the clone.");
            println!("Cloning makes a completely new copy in memory, so you can mutate the new one freely.");
            println!("The original remains unchanged.\n");

            let x = vec![1, 2, 3];
            let mut y = x.clone();

            y[0] = 99;

            println!("‚úÖ x (original, unchanged): {:?}", x);
            println!("‚úÖ y (mutated clone): {:?}", y);
        }

        _ => {
            eprintln!("‚ùå Unknown case '{}'", case);
        }
    }

    println!("==============================\n");
}

fn main() {
    run_case("mutable_clone");
}
```

